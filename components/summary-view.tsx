/**
 * Summary View Component
 *
 * Displays a summary with formatted content and PDF download functionality
 */

"use client"

import * as React from "react"
import { useRouter } from "next/navigation"
import { IconDownload, IconRefresh } from "@tabler/icons-react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog"
import { jsPDF } from "jspdf"
import { toast } from "sonner"

interface Summary {
  id: number
  date: string
  version: number
  content: string
  createdAt: string
  updatedAt: string
}

interface SummaryViewProps {
  summary: Summary
}

export function SummaryView({ summary }: SummaryViewProps) {
  const router = useRouter()
  const [isRegenerating, setIsRegenerating] = React.useState(false)

  const handleRegenerate = async () => {
    setIsRegenerating(true)
    const loadingToast = toast.loading('Regenerating summary...')

    try {
      const response = await fetch('/api/summaries/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ date: summary.date })
      })

      const data = await response.json()
      toast.dismiss(loadingToast)

      if (response.ok) {
        toast.success('Summary regenerated successfully!')
        // Refresh the page to show the new version
        router.refresh()
      } else {
        toast.error(data.error || 'Failed to regenerate summary')
      }
    } catch (error) {
      toast.dismiss(loadingToast)
      console.error('Error regenerating summary:', error)
      toast.error('Failed to regenerate summary')
    } finally {
      setIsRegenerating(false)
    }
  }

  const downloadPDF = () => {
    const doc = new jsPDF()
    const pageWidth = doc.internal.pageSize.getWidth()
    const pageHeight = doc.internal.pageSize.getHeight()
    const margin = 15
    const maxWidth = pageWidth - 2 * margin
    const bottomMargin = 20
    let yPosition = 20

    // Helper function to check if we need a new page
    const checkPageOverflow = (estimatedHeight: number) => {
      if (yPosition + estimatedHeight > pageHeight - bottomMargin) {
        doc.addPage()
        yPosition = 20
      }
    }

    // Helper function to add text with word wrapping and automatic page breaks
    const addText = (text: string, fontSize: number = 11, isBold: boolean = false) => {
      doc.setFontSize(fontSize)
      doc.setFont('helvetica', isBold ? 'bold' : 'normal')
      const lines = doc.splitTextToSize(text, maxWidth)
      const lineHeight = fontSize * 0.5

      for (let i = 0; i < lines.length; i++) {
        checkPageOverflow(lineHeight + 5)
        doc.text(lines[i], margin, yPosition)
        yPosition += lineHeight
      }

      yPosition += 5 // Add some spacing after text block
    }

    // Add title
    const [year, month, day] = summary.date.split('-').map(Number)
    const date = new Date(year, month - 1, day)
    const formattedDate = date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
    addText('Executive Summary', 18, true)
    addText(formattedDate, 12)
    if (summary.version > 1) {
      addText(`Version ${summary.version}`, 10)
    }
    yPosition += 10

    // Add content (parse markdown-like sections)
    const content = summary.content
    const sections = content.split('\n\n')

    sections.forEach(section => {
      if (!section.trim()) return

      // Check if it's a heading (starts with ## or similar)
      if (section.startsWith('##')) {
        yPosition += 5
        const heading = section.replace(/^#+\s*/, '')
        addText(heading, 14, true)
      } else if (section.startsWith('#')) {
        yPosition += 5
        const heading = section.replace(/^#+\s*/, '')
        addText(heading, 16, true)
      } else if (section.startsWith('**')) {
        // Bold section
        const text = section.replace(/\*\*/g, '')
        addText(text, 11, true)
      } else if (section.startsWith('- ') || section.startsWith('* ')) {
        // Bullet points
        const bulletPoints = section.split('\n')
        bulletPoints.forEach(point => {
          if (point.trim()) {
            const cleanPoint = point.replace(/^[-*]\s*/, 'â€¢ ')
            addText(cleanPoint, 11)
          }
        })
      } else {
        // Regular paragraph
        addText(section, 11)
      }
    })

    // Add footer
    checkPageOverflow(15)
    yPosition = pageHeight - 15
    doc.setFontSize(9)
    doc.setFont('helvetica', 'italic')
    doc.text('Generated by AI-powered Executive Summary System', margin, yPosition)

    // Download the PDF
    const filename = `summary_${summary.date}${summary.version > 1 ? `_v${summary.version}` : ''}.pdf`
    doc.save(filename)
  }

  // Format content for display (convert markdown-like syntax to HTML)
  const formatContent = (content: string) => {
    const lines = content.split('\n')
    const elements: React.ReactElement[] = []
    let inList = false
    let listItems: React.ReactElement[] = []
    let inTable = false
    let tableRows: string[][] = []

    const flushList = () => {
      if (listItems.length > 0) {
        elements.push(<ul key={`list-${elements.length}`} className="list-disc ml-6 mb-4 space-y-1">{listItems}</ul>)
        listItems = []
        inList = false
      }
    }

    const flushTable = () => {
      if (tableRows.length > 0) {
        elements.push(
          <div key={`table-${elements.length}`} className="overflow-x-auto my-4">
            <table className="min-w-full border-collapse border border-gray-300">
              <thead>
                <tr className="bg-muted">
                  {tableRows[0].map((cell, i) => (
                    <th key={i} className="border border-gray-300 px-4 py-2 text-left font-semibold">
                      {cell.trim()}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {tableRows.slice(2).map((row, i) => (
                  <tr key={i}>
                    {row.map((cell, j) => (
                      <td key={j} className="border border-gray-300 px-4 py-2">
                        {cell.trim()}
                      </td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )
        tableRows = []
        inTable = false
      }
    }

    const parseBoldAndItalic = (text: string) => {
      // Split by bold markers
      const parts = text.split(/(\*\*.*?\*\*)/g)
      return parts.map((part, i) => {
        if (part.startsWith('**') && part.endsWith('**')) {
          return <strong key={i}>{part.slice(2, -2)}</strong>
        }
        // Check for italic
        const italicParts = part.split(/(\*.*?\*)/g)
        return italicParts.map((iPart, j) => {
          if (iPart.startsWith('*') && iPart.endsWith('*') && !iPart.startsWith('**')) {
            return <em key={`${i}-${j}`}>{iPart.slice(1, -1)}</em>
          }
          return iPart
        })
      })
    }

    lines.forEach((line, index) => {
      // Check for table separator
      if (line.match(/^[\s]*---[\s]*\|/)) {
        inTable = true
        return
      }

      // Check for table rows
      if (line.includes('|') && line.split('|').length > 2) {
        const cells = line.split('|').filter(cell => cell.trim())
        tableRows.push(cells)
        return
      } else if (inTable) {
        flushTable()
      }

      // Headings
      if (line.startsWith('### ')) {
        flushList()
        elements.push(<h3 key={index} className="text-xl font-semibold mt-6 mb-3">{line.replace('### ', '')}</h3>)
        return
      }
      if (line.startsWith('## ')) {
        flushList()
        elements.push(<h2 key={index} className="text-2xl font-bold mt-8 mb-4">{line.replace('## ', '')}</h2>)
        return
      }
      if (line.startsWith('# ')) {
        flushList()
        elements.push(<h1 key={index} className="text-3xl font-bold mt-10 mb-5">{line.replace('# ', '')}</h1>)
        return
      }

      // Horizontal rules
      if (line.trim() === '---') {
        flushList()
        elements.push(<hr key={index} className="my-6 border-t border-gray-300" />)
        return
      }

      // Bullet points
      if (line.match(/^[\s]*[-*]\s/)) {
        inList = true
        const content = line.replace(/^[\s]*[-*]\s/, '')
        listItems.push(<li key={index}>{parseBoldAndItalic(content)}</li>)
        return
      } else if (inList) {
        flushList()
      }

      // Numbered lists
      if (line.match(/^[\s]*\d+\.\s/)) {
        const content = line.replace(/^[\s]*\d+\.\s/, '')
        elements.push(
          <li key={index} className="ml-6 mb-1 list-decimal">
            {parseBoldAndItalic(content)}
          </li>
        )
        return
      }

      // Empty lines
      if (line.trim() === '') {
        flushList()
        elements.push(<div key={index} className="h-2" />)
        return
      }

      // Regular paragraphs with bold/italic support
      flushList()
      elements.push(<p key={index} className="mb-3 leading-relaxed">{parseBoldAndItalic(line)}</p>)
    })

    flushList()
    flushTable()

    return elements
  }

  return (
    <div className="space-y-4">
      {/* Action Buttons */}
      <div className="flex justify-end gap-2">
        <AlertDialog>
          <AlertDialogTrigger asChild>
            <Button
              variant="destructive"
              disabled={isRegenerating}
            >
              <IconRefresh className="size-4 mr-2" />
              Regenerate Summary
            </Button>
          </AlertDialogTrigger>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Regenerate Summary?</AlertDialogTitle>
              <AlertDialogDescription>
                This will create a new version of the summary for this date. The current version will be preserved and you can access all versions from the summary list.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction onClick={handleRegenerate}>
                Regenerate
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        <Button onClick={downloadPDF} variant="outline">
          <IconDownload className="size-4 mr-2" />
          Download PDF
        </Button>
      </div>

      {/* Summary Content */}
      <Card>
        <CardContent className="p-8">
          <div className="prose prose-slate max-w-none">
            <div className="text-base">
              {formatContent(summary.content)}
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Metadata */}
      <div className="text-sm text-muted-foreground text-center">
        Generated on {new Date(summary.createdAt).toLocaleString('en-US', {
          month: 'long',
          day: 'numeric',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        })}
      </div>
    </div>
  )
}
